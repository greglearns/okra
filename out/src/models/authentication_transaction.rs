/* 
 * Okta API
 *
 * Allows customers to easily access the Okta API
 *
 * OpenAPI spec version: 1.9.0
 * Contact: devex-public@okta.com
 * Generated by: https://openapi-generator.tech
 */


#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct AuthenticationTransaction {
  #[serde(rename = "stateToken")]
  state_token: Option<String>,
  #[serde(rename = "type")]
  _type: Option<String>,
  #[serde(rename = "sessionToken")]
  session_token: Option<String>,
  #[serde(rename = "expiresAt")]
  expires_at: Option<String>,
  #[serde(rename = "status")]
  status: Option<::models::TransactionState>,
  #[serde(rename = "relayState")]
  relay_state: Option<String>,
  #[serde(rename = "factorResult")]
  factor_result: Option<::models::FactorResultType>,
  #[serde(rename = "_embedded")]
  _embedded: Option<::std::collections::HashMap<String, Value>>,
  #[serde(rename = "_links")]
  _links: Option<::std::collections::HashMap<String, Value>>
}

impl AuthenticationTransaction {
  pub fn new() -> AuthenticationTransaction {
    AuthenticationTransaction {
      state_token: None,
      _type: None,
      session_token: None,
      expires_at: None,
      status: None,
      relay_state: None,
      factor_result: None,
      _embedded: None,
      _links: None
    }
  }

  pub fn set_state_token(&mut self, state_token: String) {
    self.state_token = Some(state_token);
  }

  pub fn with_state_token(mut self, state_token: String) -> AuthenticationTransaction {
    self.state_token = Some(state_token);
    self
  }

  pub fn state_token(&self) -> Option<&String> {
    self.state_token.as_ref()
  }

  pub fn reset_state_token(&mut self) {
    self.state_token = None;
  }

  pub fn set__type(&mut self, _type: String) {
    self._type = Some(_type);
  }

  pub fn with__type(mut self, _type: String) -> AuthenticationTransaction {
    self._type = Some(_type);
    self
  }

  pub fn _type(&self) -> Option<&String> {
    self._type.as_ref()
  }

  pub fn reset__type(&mut self) {
    self._type = None;
  }

  pub fn set_session_token(&mut self, session_token: String) {
    self.session_token = Some(session_token);
  }

  pub fn with_session_token(mut self, session_token: String) -> AuthenticationTransaction {
    self.session_token = Some(session_token);
    self
  }

  pub fn session_token(&self) -> Option<&String> {
    self.session_token.as_ref()
  }

  pub fn reset_session_token(&mut self) {
    self.session_token = None;
  }

  pub fn set_expires_at(&mut self, expires_at: String) {
    self.expires_at = Some(expires_at);
  }

  pub fn with_expires_at(mut self, expires_at: String) -> AuthenticationTransaction {
    self.expires_at = Some(expires_at);
    self
  }

  pub fn expires_at(&self) -> Option<&String> {
    self.expires_at.as_ref()
  }

  pub fn reset_expires_at(&mut self) {
    self.expires_at = None;
  }

  pub fn set_status(&mut self, status: ::models::TransactionState) {
    self.status = Some(status);
  }

  pub fn with_status(mut self, status: ::models::TransactionState) -> AuthenticationTransaction {
    self.status = Some(status);
    self
  }

  pub fn status(&self) -> Option<&::models::TransactionState> {
    self.status.as_ref()
  }

  pub fn reset_status(&mut self) {
    self.status = None;
  }

  pub fn set_relay_state(&mut self, relay_state: String) {
    self.relay_state = Some(relay_state);
  }

  pub fn with_relay_state(mut self, relay_state: String) -> AuthenticationTransaction {
    self.relay_state = Some(relay_state);
    self
  }

  pub fn relay_state(&self) -> Option<&String> {
    self.relay_state.as_ref()
  }

  pub fn reset_relay_state(&mut self) {
    self.relay_state = None;
  }

  pub fn set_factor_result(&mut self, factor_result: ::models::FactorResultType) {
    self.factor_result = Some(factor_result);
  }

  pub fn with_factor_result(mut self, factor_result: ::models::FactorResultType) -> AuthenticationTransaction {
    self.factor_result = Some(factor_result);
    self
  }

  pub fn factor_result(&self) -> Option<&::models::FactorResultType> {
    self.factor_result.as_ref()
  }

  pub fn reset_factor_result(&mut self) {
    self.factor_result = None;
  }

  pub fn set__embedded(&mut self, _embedded: ::std::collections::HashMap<String, Value>) {
    self._embedded = Some(_embedded);
  }

  pub fn with__embedded(mut self, _embedded: ::std::collections::HashMap<String, Value>) -> AuthenticationTransaction {
    self._embedded = Some(_embedded);
    self
  }

  pub fn _embedded(&self) -> Option<&::std::collections::HashMap<String, Value>> {
    self._embedded.as_ref()
  }

  pub fn reset__embedded(&mut self) {
    self._embedded = None;
  }

  pub fn set__links(&mut self, _links: ::std::collections::HashMap<String, Value>) {
    self._links = Some(_links);
  }

  pub fn with__links(mut self, _links: ::std::collections::HashMap<String, Value>) -> AuthenticationTransaction {
    self._links = Some(_links);
    self
  }

  pub fn _links(&self) -> Option<&::std::collections::HashMap<String, Value>> {
    self._links.as_ref()
  }

  pub fn reset__links(&mut self) {
    self._links = None;
  }

}



