/* 
 * Okta API
 *
 * Allows customers to easily access the Okta API
 *
 * OpenAPI spec version: 1.9.0
 * Contact: devex-public@okta.com
 * Generated by: https://openapi-generator.tech
 */


#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct PasswordPolicyPasswordSettingsComplexity {
  #[serde(rename = "dictionary")]
  dictionary: Option<::models::PasswordDictionary>,
  #[serde(rename = "excludeAttributes")]
  exclude_attributes: Option<Vec<String>>,
  #[serde(rename = "excludeUsername")]
  exclude_username: Option<bool>,
  #[serde(rename = "minLength")]
  min_length: Option<i32>,
  #[serde(rename = "minLowerCase")]
  min_lower_case: Option<i32>,
  #[serde(rename = "minNumber")]
  min_number: Option<i32>,
  #[serde(rename = "minSymbol")]
  min_symbol: Option<i32>,
  #[serde(rename = "minUpperCase")]
  min_upper_case: Option<i32>
}

impl PasswordPolicyPasswordSettingsComplexity {
  pub fn new() -> PasswordPolicyPasswordSettingsComplexity {
    PasswordPolicyPasswordSettingsComplexity {
      dictionary: None,
      exclude_attributes: None,
      exclude_username: None,
      min_length: None,
      min_lower_case: None,
      min_number: None,
      min_symbol: None,
      min_upper_case: None
    }
  }

  pub fn set_dictionary(&mut self, dictionary: ::models::PasswordDictionary) {
    self.dictionary = Some(dictionary);
  }

  pub fn with_dictionary(mut self, dictionary: ::models::PasswordDictionary) -> PasswordPolicyPasswordSettingsComplexity {
    self.dictionary = Some(dictionary);
    self
  }

  pub fn dictionary(&self) -> Option<&::models::PasswordDictionary> {
    self.dictionary.as_ref()
  }

  pub fn reset_dictionary(&mut self) {
    self.dictionary = None;
  }

  pub fn set_exclude_attributes(&mut self, exclude_attributes: Vec<String>) {
    self.exclude_attributes = Some(exclude_attributes);
  }

  pub fn with_exclude_attributes(mut self, exclude_attributes: Vec<String>) -> PasswordPolicyPasswordSettingsComplexity {
    self.exclude_attributes = Some(exclude_attributes);
    self
  }

  pub fn exclude_attributes(&self) -> Option<&Vec<String>> {
    self.exclude_attributes.as_ref()
  }

  pub fn reset_exclude_attributes(&mut self) {
    self.exclude_attributes = None;
  }

  pub fn set_exclude_username(&mut self, exclude_username: bool) {
    self.exclude_username = Some(exclude_username);
  }

  pub fn with_exclude_username(mut self, exclude_username: bool) -> PasswordPolicyPasswordSettingsComplexity {
    self.exclude_username = Some(exclude_username);
    self
  }

  pub fn exclude_username(&self) -> Option<&bool> {
    self.exclude_username.as_ref()
  }

  pub fn reset_exclude_username(&mut self) {
    self.exclude_username = None;
  }

  pub fn set_min_length(&mut self, min_length: i32) {
    self.min_length = Some(min_length);
  }

  pub fn with_min_length(mut self, min_length: i32) -> PasswordPolicyPasswordSettingsComplexity {
    self.min_length = Some(min_length);
    self
  }

  pub fn min_length(&self) -> Option<&i32> {
    self.min_length.as_ref()
  }

  pub fn reset_min_length(&mut self) {
    self.min_length = None;
  }

  pub fn set_min_lower_case(&mut self, min_lower_case: i32) {
    self.min_lower_case = Some(min_lower_case);
  }

  pub fn with_min_lower_case(mut self, min_lower_case: i32) -> PasswordPolicyPasswordSettingsComplexity {
    self.min_lower_case = Some(min_lower_case);
    self
  }

  pub fn min_lower_case(&self) -> Option<&i32> {
    self.min_lower_case.as_ref()
  }

  pub fn reset_min_lower_case(&mut self) {
    self.min_lower_case = None;
  }

  pub fn set_min_number(&mut self, min_number: i32) {
    self.min_number = Some(min_number);
  }

  pub fn with_min_number(mut self, min_number: i32) -> PasswordPolicyPasswordSettingsComplexity {
    self.min_number = Some(min_number);
    self
  }

  pub fn min_number(&self) -> Option<&i32> {
    self.min_number.as_ref()
  }

  pub fn reset_min_number(&mut self) {
    self.min_number = None;
  }

  pub fn set_min_symbol(&mut self, min_symbol: i32) {
    self.min_symbol = Some(min_symbol);
  }

  pub fn with_min_symbol(mut self, min_symbol: i32) -> PasswordPolicyPasswordSettingsComplexity {
    self.min_symbol = Some(min_symbol);
    self
  }

  pub fn min_symbol(&self) -> Option<&i32> {
    self.min_symbol.as_ref()
  }

  pub fn reset_min_symbol(&mut self) {
    self.min_symbol = None;
  }

  pub fn set_min_upper_case(&mut self, min_upper_case: i32) {
    self.min_upper_case = Some(min_upper_case);
  }

  pub fn with_min_upper_case(mut self, min_upper_case: i32) -> PasswordPolicyPasswordSettingsComplexity {
    self.min_upper_case = Some(min_upper_case);
    self
  }

  pub fn min_upper_case(&self) -> Option<&i32> {
    self.min_upper_case.as_ref()
  }

  pub fn reset_min_upper_case(&mut self) {
    self.min_upper_case = None;
  }

}



